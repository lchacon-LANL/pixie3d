#!/bin/bash

help()
{
cat <<HELP
Usage: 

$0 submit_script [job#]

where:
	submit_script: is the script file to be submitted
	job#:          is an optional job number to begin monitoring
HELP
exit 0
}

check_job()
{
RUNTEST=""
while [ "$RUNTEST" != "State: Running" -a "$RUNTEST" != "State: Completed" ]
do
  sleep 30
  checkjob $1 > currentjob.txt
  RUNTEST=$(grep State currentjob.txt | xargs)
  echo 'result=' $RUNTEST
done
rm currentjob.txt
}

check_return_code()
{
echo "Checking return value for job $JOB"
RETURN_VALUE=""
while [ "$RETURN_VALUE" = "" ]
do
  echo "Waiting for return value..."
  sleep 120
  RETURN_VALUE=$(cat exit_code.txt 2> /dev/null)
done
echo "Return value found: $RETURN_VALUE"
}

new_job()
{
sed -e s/"restart  = f"/"restart  = t"/g pixie3d.in > pixie3d.in2
mv pixie3d.in2 pixie3d.in
rm exit_code.txt
JOB=$(msub $1 -l depend=$JOB | xargs)
echo 'New JOB='$JOB

check_job $JOB

check_return_code

if [ "$RETURN_VALUE" = "1" ]; then
  new_job $1
fi
}

#Parse input options

if [ "$#" = 0 ]; then
  help
  exit 1
fi

# Begin script

date

# First submission

JOB="$2"

if [ "$JOB" = "" ]; then
  rm exit_code.txt
  JOB=$(msub $1 | xargs)
  echo 'New JOB='$JOB
fi

check_job $JOB

check_return_code

# Subsequent submissions

if [ "$RETURN_VALUE" = "1" ]; then  #CPU quota exit; restart
  new_job $1
fi

#Clean up

date

rm exit_code.txt
echo 'Done'
exit
